<!DOCTYPE html>

<html>
<head>
  <title>delorean.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="delorean.html">
                delorean.js
              </a>
            
              
              <a class="source" href="requirements.html">
                requirements.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>delorean.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(DeLorean)</span> </span>{
<span class="hljs-pi">  'use strict'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>There are two main concepts in Flux structure: <strong>Dispatchers</strong> and <strong>Stores</strong>.
Action Creators are simply helpers but doesn’t require any framework level
abstraction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> Dispatcher, Store;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="private-helper-functions">Private Helper Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Helper functions are private functions to be used in codebase.
It’s better using two underscore at the beginning of the function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-comment">/* `__hasOwn` function is a shortcut for `Object#hasOwnProperty` */</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__hasOwn</span><span class="hljs-params">(object, prop)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(object, prop);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Use <code>__generateActionName</code> function to generate action names.
E.g. If you create an action with name <code>hello</code> it will be
<code>action:hello</code> for the Flux.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__generateActionName</span><span class="hljs-params">(name)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'action:'</span> + name;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>__findDispatcher</code> is a private function for <strong>React components</strong>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__findDispatcher</span><span class="hljs-params">(view)</span> </span>{
    <span class="hljs-comment">/* `view` should be a component instance. If a component don't have
        any dispatcher, it tries to find a dispatcher from the parents. */</span>
    <span class="hljs-keyword">if</span> (!view.props.dispatcher) {
      <span class="hljs-keyword">return</span> __findDispatcher(view._owner);
    }
    <span class="hljs-keyword">return</span> view.props.dispatcher;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="dispatcher">Dispatcher</h2>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The dispatcher is <strong>the central hub</strong> that <strong>manages all data flow</strong> in
a Flux application. It is essentially a <em>registry of callbacks into the
stores</em>. Each store registers itself and provides a callback. When the
dispatcher responds to an action, all stores in the application are sent
the data payload provided by the action via the callbacks in the registry.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Dispatcher = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h3 id="dispatcher-helpers">Dispatcher Helpers</h3>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Rollback listener adds a <code>rollback</code> event listener to the bunch of
stores.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__rollbackListener</span><span class="hljs-params">(stores)</span> </span>{

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__listener</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> stores) {
          stores[i].listener.emit(<span class="hljs-string">'__rollback'</span>);
        }
      }

      <span class="hljs-comment">/* If any of them fires `rollback` event, all of the stores
         will be emitted to be rolled back with `__rollback` event. */</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j <span class="hljs-keyword">in</span> stores) {
        stores[j].listener.on(<span class="hljs-string">'rollback'</span>, __listener);
      }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h3 id="dispatcher-prototype">Dispatcher Prototype</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dispatcher</span><span class="hljs-params">(stores)</span> </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><code>DeLorean.EventEmitter</code> is <code>require(&#39;events&#39;).EventEmitter</code> by default.
you can change it using <code>DeLorean.Flux.define(&#39;EventEmitter&#39;, AnotherEventEmitter)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.listener = <span class="hljs-keyword">new</span> DeLorean.EventEmitter();
      <span class="hljs-keyword">this</span>.stores = stores;

      <span class="hljs-comment">/* Stores should be listened for rollback events. */</span>
      __rollbackListener(<span class="hljs-built_in">Object</span>.keys(stores).map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key)</span> </span>{
        <span class="hljs-keyword">return</span> stores[key];
      }));
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>dispatch</code> method dispatch the event with <code>data</code> (or <strong>payload</strong>)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(actionName, data)</span> </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, stores, deferred;

      <span class="hljs-comment">/* Stores are key-value pairs. Collect store instances into an array. */</span>
      stores = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> stores = [], store;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> self.stores) {
          store = self.stores[storeName];
          <span class="hljs-comment">/* Store value must be an _instance of Store_. */</span>
          <span class="hljs-keyword">if</span> (!store <span class="hljs-keyword">instanceof</span> Store) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'Given store is not a store instance'</span>;
          }
          stores.push(store);
        }
        <span class="hljs-keyword">return</span> stores;
      }());</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Store instances should wait for finish. So you can know if all the
stores are dispatched properly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      deferred = <span class="hljs-keyword">this</span>.waitFor(stores);

      <span class="hljs-comment">/* Payload should send to all related stores. */</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> self.stores) {
        self.stores[storeName].dispatchAction(actionName, data);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><code>dispatch</code> returns deferred object you can just use <strong>promise</strong>
for dispatching: <code>dispatch(..).then(..)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> deferred;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><code>waitFor</code> is actually a <em>semi-private</em> method. Because it’s kind of internal
and you don’t need to call it from outside most of the times. It takes
array of store instances (<code>[Store, Store, Store, ...]</code>). It will create
a promise and return it. <em>Whenever store changes, it resolves the promise</em>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.waitFor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(stores)</span> </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, promises;
      promises = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> __promises = [], promise;

        <span class="hljs-comment">/* `__promiseGenerator` generates a simple promise that resolves itself when
            related store is changed. */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__promiseGenerator</span><span class="hljs-params">(store)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p><code>DeLorean.Promise</code> is <code>require(&#39;es6-promise&#39;).Promise</code> by default.
you can change it using <code>DeLorean.Flux.define(&#39;Promise&#39;, AnotherPromise)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DeLorean.Promise(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve, reject)</span> </span>{
            store.listener.once(<span class="hljs-string">'change'</span>, resolve);
          });
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> stores) {
          promise = __promiseGenerator(stores[i]);
          __promises.push(promise);
        }
        <span class="hljs-keyword">return</span> __promises;
      }());</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>When all the promises are resolved, dispatcher emits <code>change:all</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> DeLorean.Promise.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        self.listener.emit(<span class="hljs-string">'change:all'</span>);
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p><code>registerAction</code> method adds a method to the prototype. So you can just use
<code>dispatcherInstance.actionName()</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.registerAction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(action, callback)</span> </span>{
      <span class="hljs-comment">/* The callback must be a function. */</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">this</span>[action] = callback.bind(<span class="hljs-keyword">this</span>.stores);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Action callback should be a function.'</span>;
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p><code>getStore</code> returns the store from stores hash.
You can also use <code>dispatcherInstance.stores[storeName]</code> but
it checks if the store really exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Dispatcher.prototype.getStore = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(storeName)</span> </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.stores[storeName]) {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Store '</span> + storeName + <span class="hljs-string">' does not exist.'</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores[storeName].store;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h3 id="shortcuts">Shortcuts</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    Dispatcher.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listener.on.apply(<span class="hljs-keyword">this</span>.listener, <span class="hljs-built_in">arguments</span>);
    };

    Dispatcher.prototype.off = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listener.removeListener.apply(<span class="hljs-keyword">this</span>.listener, <span class="hljs-built_in">arguments</span>);
    };

    Dispatcher.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listener.emit.apply(<span class="hljs-keyword">this</span>.listener, <span class="hljs-built_in">arguments</span>);
    };

    <span class="hljs-keyword">return</span> Dispatcher;
  }());</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="store">Store</h2>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Stores contain the application state and logic. Their role is somewhat similar
to a model in a traditional MVC, but they manage the state of many objects.
Unlike MVC models, they are not instances of one object, nor are they the
same as Backbone’s collections. More than simply managing a collection of
ORM-style objects, stores manage the application state for a particular
domain within the application.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Store = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h3 id="store-prototype">Store Prototype</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Store</span><span class="hljs-params">(store, args)</span> </span>{
      <span class="hljs-comment">/* store parameter must be an `object` */</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> store !== <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Stores should be defined by passing the definition to the constructor'</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p><code>DeLorean.EventEmitter</code> is <code>require(&#39;events&#39;).EventEmitter</code> by default.
you can change it using <code>DeLorean.Flux.define(&#39;EventEmitter&#39;, AnotherEventEmitter)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.listener = <span class="hljs-keyword">new</span> DeLorean.EventEmitter();

      <span class="hljs-comment">/* Store is _hygenic_ object. DeLorean doesn't extend it, it uses it. */</span>
      <span class="hljs-keyword">this</span>.store = store;
      <span class="hljs-keyword">this</span>.bindActions();

      <span class="hljs-keyword">this</span>.buildScheme();</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><code>initialize</code> is the construction function, you can define <code>initialize</code> method
in your store definitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> store.initialize === <span class="hljs-string">'function'</span>) {
        store.initialize.apply(<span class="hljs-keyword">this</span>.store, args);
      }
    }

    Store.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, value)</span> </span>{
      <span class="hljs-keyword">var</span> scheme = <span class="hljs-keyword">this</span>.store.scheme, definition;
      <span class="hljs-keyword">if</span> (scheme &amp;&amp; <span class="hljs-keyword">this</span>.store.scheme[key]) {
        definition = scheme[key];

        <span class="hljs-keyword">this</span>.store[key] = value || definition.default;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> definition.calculate === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">this</span>.store[key] = definition.calculate.call(<span class="hljs-keyword">this</span>.store);
        }

        <span class="hljs-keyword">this</span>.listener.emit(<span class="hljs-string">'change'</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">'Scheme should include the key '</span> + key + <span class="hljs-string">' you wanted to set.'</span>;
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Removes the scheme format and standardizes all the shortcuts.
If you run <code>formatScheme({name: &#39;joe&#39;})</code> it will return you
<code>{name: {default: &#39;joe&#39;}}</code>. Also if you run <code>formatScheme({fullname: function () {}})</code>
it will return <code>{fullname: {calculate: function () {}}}</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.formatScheme = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(scheme)</span> </span>{
      <span class="hljs-keyword">var</span> formattedScheme = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> keyName <span class="hljs-keyword">in</span> scheme) {
        <span class="hljs-keyword">var</span> definition = scheme[keyName], defaultValue, calculatedValue;

        formattedScheme[keyName] = {<span class="hljs-keyword">default</span>: <span class="hljs-literal">null</span>};

        <span class="hljs-comment">/* {key: 'value'} will be {key: {default: 'value'}} */</span>
        defaultValue = (<span class="hljs-keyword">typeof</span> definition === <span class="hljs-string">'object'</span>) ?
                        definition.default : definition;
        formattedScheme[keyName].default = defaultValue;

        <span class="hljs-comment">/* {key: function () {}} will be {key: {calculate: function () {}}} */</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> definition.calculate === <span class="hljs-string">'function'</span>) {
          calculatedValue = definition.calculate;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> definition === <span class="hljs-string">'function'</span>) {
          calculatedValue = definition;
        }
        <span class="hljs-keyword">if</span> (calculatedValue) {
          formattedScheme[keyName].calculate = calculatedValue;
        }
      }
      <span class="hljs-keyword">return</span> formattedScheme;
    };

    <span class="hljs-comment">/* Applying `scheme` to the store if exists. */</span>
    Store.prototype.buildScheme = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

      <span class="hljs-keyword">var</span> scheme, calculatedData, keyName, definition;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.store.scheme === <span class="hljs-string">'object'</span>) {
        <span class="hljs-comment">/* Scheme must be formatted to standardize the keys. */</span>
        scheme = <span class="hljs-keyword">this</span>.store.scheme = <span class="hljs-keyword">this</span>.formatScheme(<span class="hljs-keyword">this</span>.store.scheme);

        <span class="hljs-comment">/* Set the defaults first */</span>
        <span class="hljs-keyword">for</span> (keyName <span class="hljs-keyword">in</span> scheme) {
          definition = scheme[keyName];
          <span class="hljs-keyword">this</span>.store[keyName] = definition.default;
        }

        <span class="hljs-comment">/* Set the calculations */</span>
        <span class="hljs-keyword">for</span> (keyName <span class="hljs-keyword">in</span> scheme) {
          definition = scheme[keyName];
          <span class="hljs-keyword">if</span> (definition.calculate) {
            <span class="hljs-keyword">this</span>.store[keyName] = definition.calculate.call(<span class="hljs-keyword">this</span>.store);
          }
        }
      }

    };</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p><code>bindActions</code> is semi-private method. You’ll never need to call it from outside.
It powers up the <code>this.store</code> object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.bindActions = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">var</span> callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Some required methods can be used in <strong>store definition</strong> like
<strong><code>emit</code></strong>, <strong><code>emitChange</code></strong>, <strong><code>emitRollback</code></strong>, <strong><code>rollback</code></strong>, <strong><code>listenChanges</code></strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.store.emit = <span class="hljs-keyword">this</span>.listener.emit.bind(<span class="hljs-keyword">this</span>.listener);
      <span class="hljs-keyword">this</span>.store.emitChange = <span class="hljs-keyword">this</span>.listener.emit.bind(<span class="hljs-keyword">this</span>.listener, <span class="hljs-string">'change'</span>);
      <span class="hljs-keyword">this</span>.store.emitRollback = <span class="hljs-keyword">this</span>.listener.emit.bind(<span class="hljs-keyword">this</span>.listener, <span class="hljs-string">'rollback'</span>);
      <span class="hljs-keyword">this</span>.store.rollback = <span class="hljs-keyword">this</span>.listener.on.bind(<span class="hljs-keyword">this</span>.listener, <span class="hljs-string">'__rollback'</span>);
      <span class="hljs-keyword">this</span>.store.listenChanges = <span class="hljs-keyword">this</span>.listenChanges.bind(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">this</span>.store.set = <span class="hljs-keyword">this</span>.set.bind(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Stores must have a <code>actions</code> hash of <code>actionName: methodName</code>
<code>methodName</code> is the <code>this.store</code>‘s prototype method..</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> actionName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.store.actions) {
        <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.store.actions, actionName)) {
          callback = <span class="hljs-keyword">this</span>.store.actions[actionName];
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.store[callback] !== <span class="hljs-string">'function'</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'Callback should be a method!'</span>;
          }
          <span class="hljs-comment">/* And `actionName` should be a name generated by `__generateActionName` */</span>
          <span class="hljs-keyword">this</span>.listener.on(__generateActionName(actionName),
                           <span class="hljs-keyword">this</span>.store[callback].bind(<span class="hljs-keyword">this</span>.store));
        }
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p><code>dispatchAction</code> called from a dispatcher. You can also call anywhere but
you probably won’t need to do. It simply <strong>emits an event with a payload</strong>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.dispatchAction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(actionName, data)</span> </span>{
      <span class="hljs-keyword">this</span>.listener.emit(__generateActionName(actionName), data);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h3 id="shortcuts">Shortcuts</h3>

            </div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><code>listenChanges</code> is a shortcut for <code>Object.observe</code> usage. You can just use
<code>Object.observe(object, function () { ... })</code> but everytime you use it you
repeat yourself. DeLorean has a shortcut doing this properly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.listenChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(object)</span> </span>{
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, observer;
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.observe) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Store#listenChanges method uses Object.observe, you should fire changes manually.'</span>);
        <span class="hljs-keyword">return</span>;
      }

      observer = <span class="hljs-built_in">Array</span>.isArray(object) ? <span class="hljs-built_in">Array</span>.observe : <span class="hljs-built_in">Object</span>.observe;

      observer(object, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(changes)</span> </span>{
        self.listener.emit(<span class="hljs-string">'change'</span>, changes);
      });
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>onChange</code> simply listens changes and calls a callback. Shortcut for
a <code>on(&#39;change&#39;)</code> command.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Store.prototype.onChange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>{
      <span class="hljs-keyword">this</span>.listener.on(<span class="hljs-string">'change'</span>, callback);
    };

    <span class="hljs-keyword">return</span> Store;
  }());</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h3 id="flux-wrapper">Flux Wrapper</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>  DeLorean.Flux = {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>createStore</code> <strong>creates a function to create a store</strong>. So it’s like
a factory.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    createStore: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(factoryDefinition)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Store(factoryDefinition, <span class="hljs-built_in">arguments</span>);
      };
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><code>createDispatcher</code> generates a dispatcher with actions to dispatch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-comment">/* `actionsToDispatch` should be an object. */</span>
    createDispatcher: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(actionsToDispatch)</span> </span>{
      <span class="hljs-keyword">var</span> actionsOfStores, dispatcher, callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>If it has <code>getStores</code> method it should be get and pass to the <code>Dispatcher</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionsToDispatch.getStores === <span class="hljs-string">'function'</span>) {
        actionsOfStores = actionsToDispatch.getStores();
      }

      <span class="hljs-comment">/* If there are no stores defined, it's an empty object. */</span>
      dispatcher = <span class="hljs-keyword">new</span> Dispatcher(actionsOfStores || {});

      <span class="hljs-comment">/* Now call `registerAction` method for every action. */</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> actionName <span class="hljs-keyword">in</span> actionsToDispatch) {
        <span class="hljs-keyword">if</span> (__hasOwn(actionsToDispatch, actionName)) {
          <span class="hljs-comment">/* `getStores` is the special function, it's not an action. */</span>
          <span class="hljs-keyword">if</span> (actionName !== <span class="hljs-string">'getStores'</span>) {
            callback = actionsToDispatch[actionName];
            dispatcher.registerAction(actionName, callback.bind(dispatcher));
          }
        }
      }

      <span class="hljs-keyword">return</span> dispatcher;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h3 id="-delorean-flux-define-"><code>DeLorean.Flux.define</code></h3>
<p>It’s a key to <em>hack</em> DeLorean easily. You can just inject something
you want to define.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    define: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, value)</span> </span>{
      DeLorean[key] = value;
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Store and Dispatcher are the only base classes of DeLorean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  DeLorean.Dispatcher = Dispatcher;
  DeLorean.Store = Store;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h2 id="built-in-react-mixin">Built-in React Mixin</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>  DeLorean.Flux.mixins = {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>It should be inserted to the React components which
used in Flux.
Simply <code>mixin: [Flux.mixins.storeListener]</code> will work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    storeListener: {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>After the component mounted, listen changes of the related stores</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      componentDidMount: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, store;

        <span class="hljs-comment">/* `__changeHandler` is a **listener generator** to pass to the `onChange` function. */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__changeHandler</span><span class="hljs-params">(store, storeName)</span> </span>{
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> state, args;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>When something changes it calls the components <code>storeDidChanged</code> method if exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (self.storeDidChange) {
              args = [storeName].concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>));
              self.storeDidChange.apply(self, args);
            }
            <span class="hljs-comment">/* If the component is mounted, change state. */</span>
            <span class="hljs-keyword">if</span> (self.isMounted()) {
              self.setState(self.getStoreStates());
            }
          };
        }

        <span class="hljs-comment">/* Generate and bind the change handlers to the stores. */</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.stores) {
          <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.stores, storeName)) {
            store = <span class="hljs-keyword">this</span>.stores[storeName];
            store.onChange(__changeHandler(store, storeName));
          }
        }
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>When a component unmounted, it should stop listening.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      componentWillUnmount: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.stores) {
          <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.stores, storeName)) {
            <span class="hljs-keyword">var</span> store = <span class="hljs-keyword">this</span>.stores[storeName];
            <span class="hljs-comment">/* FIXME: What if another mounted view listening this store? Commenting out for now. */</span>
            store.listener.removeAllListeners(<span class="hljs-string">'change'</span>);
          }
        }
      },

      getInitialState: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>, state;

        <span class="hljs-comment">/* The dispatcher should be easy to access and it should use `__findDispatcher`
           method to find the parent dispatchers. */</span>
        <span class="hljs-keyword">this</span>.dispatcher = __findDispatcher(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>If <code>storesDidChange</code> method presents, it’ll be called after all the stores
were changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.storesDidChange) {
          <span class="hljs-keyword">this</span>.dispatcher.on(<span class="hljs-string">'change:all'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            self.storesDidChange();
          });
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Since <code>dispatcher.stores</code> is harder to write, there’s a shortcut for it.
You can use <code>this.stores</code> from the React component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.stores = <span class="hljs-keyword">this</span>.dispatcher.stores;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getStoreStates();
      },

      getStoreStates: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> state = {stores: {}};

        <span class="hljs-comment">/* Set `state.stores` for all present stores with a `setState` method defined. */</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> storeName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.stores) {
          <span class="hljs-keyword">if</span> (__hasOwn(<span class="hljs-keyword">this</span>.stores, storeName)) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stores[storeName]
            &amp;&amp; <span class="hljs-keyword">this</span>.stores[storeName].store</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>If stores has <code>getState</code> method, it’ll be pushed to the component’s state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            &amp;&amp; <span class="hljs-keyword">this</span>.stores[storeName].store.getState) {
              state.stores[storeName] = <span class="hljs-keyword">this</span>.stores[storeName].store.getState();
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'state not found, getting scheme'</span>);
            }
          }
        }
        <span class="hljs-keyword">return</span> state;
      },</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p><code>getStore</code> is a shortcut to get the store from the state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      getStore: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(storeName)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.stores[storeName];
      }
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h2 id="delorean-api">DeLorean API</h2>
<p>DeLorean can be used in <strong>CommonJS</strong> projects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span>.exports !== <span class="hljs-string">'undefined'</span>) {

    <span class="hljs-keyword">var</span> requirements = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./requirements'</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> requirement <span class="hljs-keyword">in</span> requirements) {
      DeLorean.Flux.define(requirement, requirements[requirement]);
    }
    <span class="hljs-built_in">module</span>.exports = DeLorean;</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>It can be also used in <strong>AMD</strong> projects, too.
And if there is no module system initialized, just pass the DeLorean
to the <code>window</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
      define([], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> DeLorean;
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">window</span>.DeLorean = DeLorean;
    }
  }

})({});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
